{
  "hash": "9826691d00ba745a9883801aca59b6b0",
  "result": {
    "markdown": "---\ntitle: \"Synthetic Population with simPop\"\ntoc: true\n---\n\n\n## Why synthetic population?\n\nPurpose\n\n-   Data privacy\n\n-   Scale up sample data to better fit the distribution of population\n\nApplication\n\n-   input data for machine learning (which requires a lot of data)\n\n-   use as population for simulation problems\n\n## Types of data\n\nMacro data:\n\n-   IPUMS data (at district level)\n\nMicro data:\n\n-   HCDC data\n\n## Methodology\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# so does synthetic reconstruction basically assigning non-integer weight to a synthetic microdata while combination optimization assigning integer weight to available micro data and both aim to have a population that match a macro data??\n```\n:::\n\n\n### Synthetic Reconstruction (SR)\n\nKeyword: re-weight\n\n### Combinatorial Optimization (CO)\n\nKeyword: re-sample\n\nPerhaps combine Synthetic Reconstruct (SR) technique to re-weight district level aggregated data and use that for CO?\n\nAlgorithm for CO:\n\n-   Generative algo (less susceptible to local maxima)\n\n    -   package GA, genSA\n\n-   Modified simulated annealing\n\nPackage related to synthetic population:\n\n-   simPop\n\n### Model for prediction\n\n### Overall process\n\n## Code using simPop\n\nMostly follows SR and model\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(simPop)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'simPop' was built under R version 4.3.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: lattice\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: vcd\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'vcd' was built under R version 4.3.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: grid\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPackage simPop 2.1.3 has been loaded!\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nSince simPop does explicit parallelization,\n the number of data.table threads is set to 1.\n```\n:::\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'ggplot2' was built under R version 4.3.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'dplyr' was built under R version 4.3.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'stringr' was built under R version 4.3.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n:::\n\n\n### Input data\n\nUse survey data (micro data) as input\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use built-in survey data for demonstration purpose\ndata(\"eusilcS\")\n\n# rename some important variables for readability\neusilcS <- eusilcS %>% rename(hhid = db030, state = db040, gender = rb090, economic_status = pl030, weight = rb050, citizenship = pb220a)\n\nhead(eusilcS) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     hhid hsize         state age gender economic_status citizenship netIncome\n9292    1     2      Salzburg  72   male               5          AT  22675.48\n9293    1     2      Salzburg  66 female               5          AT  16999.29\n7227    2     1 Upper Austria  56 female               2          AT  19274.21\n5275    3     1        Styria  67 female               5          AT  13319.13\n7866    4     3 Upper Austria  70 female               5          AT  14365.57\n7867    4     3 Upper Austria  46   male               3          AT      0.00\n       py010n py050n py090n   py100n py110n py120n   py130n py140n    db090\n9292     0.00      0      0 22675.48      0      0     0.00      0 7.822929\n9293     0.00      0      0     0.00      0      0 16999.29      0 7.822929\n7227 19274.21      0      0     0.00      0      0     0.00      0 8.788089\n5275     0.00      0      0 13319.13      0      0     0.00      0 8.108452\n7866     0.00      0      0 14365.57      0      0     0.00      0 7.509383\n7867     0.00      0      0     0.00      0      0     0.00      0 7.509383\n       weight\n9292 7.822929\n9293 7.822929\n7227 8.788089\n5275 8.108452\n7866 7.509383\n7867 7.509383\n```\n:::\n:::\n\n\nCreate `dataObj` using `specifyInput`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninputData <- specifyInput(\n  eusilcS,\n  hhid = \"hhid\", # specify variable for household id\n  hhsize = \"hsize\", # specify household size\n  strata = \"state\", # variable on stata (regions, etc.)\n  weight = \"weight\" # variable for sample weight (note that the sample weight is reduced by a factor of 100)\n  )\n\ninputData\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n -------------- \nsurvey sample of size 11725 x 19 \n\n Selected important variables: \n\n household ID: hhid\n personal ID: pid\n variable household size: hsize\n sampling weight: weight\n strata: state\n -------------- \n```\n:::\n:::\n\n\n### Calibrating sample weight\n\nCalibrating sample weight by population totals (if the total population aka. macro data is available)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"totalsRG\")\ntotalsRG %>% \n  arrange(db040, rb090)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    rb090         db040   Freq\n1  female    Burgenland 146980\n2    male    Burgenland 140436\n3  female     Carinthia 285797\n4    male     Carinthia 270084\n5  female Lower Austria 828087\n6    male Lower Austria 797398\n7  female      Salzburg 722883\n8    male      Salzburg 702539\n9  female        Styria 274675\n10   male        Styria 259595\n11 female         Tyrol 619404\n12   male         Tyrol 595842\n13 female Upper Austria 368128\n14   male Upper Austria 353910\n15 female        Vienna 916150\n16   male        Vienna 850596\n17 female    Vorarlberg 190343\n18   male    Vorarlberg 184939\n```\n:::\n:::\n\n\nCompared to input data\n\n\n::: {.cell}\n\n```{.r .cell-code}\neusilcS %>% \n  group_by(gender, state) %>% \n  summarize(\n    freq = n()\n  ) %>% arrange(state, gender)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'gender'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 18 × 3\n# Groups:   gender [2]\n   gender state          freq\n   <fct>  <fct>         <int>\n 1 male   Burgenland      200\n 2 female Burgenland      233\n 3 male   Carinthia       461\n 4 female Carinthia       466\n 5 male   Lower Austria  1050\n 6 female Lower Austria  1030\n 7 male   Salzburg        393\n 8 female Salzburg        386\n 9 male   Styria          907\n10 female Styria          952\n11 male   Tyrol           550\n12 female Tyrol           569\n13 male   Upper Austria  1052\n14 female Upper Austria  1068\n15 male   Vienna          844\n16 female Vienna          945\n17 male   Vorarlberg      307\n18 female Vorarlberg      312\n```\n:::\n:::\n\n\nSince the `weight` is reduced by a factor of 100, total population must also be scaled down by 100 before calibrating\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntotalsRG <- totalsRG %>% \n  mutate(Freq = Freq/100) %>% \n  rename( # rename to match colnames in inputData\n    gender = rb090, state = db040\n  )\n\n# then calibrate the input data\ncalibratedWeights <- calibSample(inputData, totalsRG)\n\n# calibrated weights can then be added to input data\naddWeights(inputData) <- calibratedWeights\n```\n:::\n\n\n### Generate synthetic population data\n\n#### Generate household structure\n\nBuilt by resampling households from micro data (basically using CO with constraints being basic variables from macro data)\n\n***Why*****?** Prevent creation of unrealistic household\n\nSampling technique: *Alias sampling*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsyntheticPopulation <- simStructure(\n  data = inputData, \n  method = \"direct\",\n  basicHHvars = c(\"age\", \"gender\", \"state\")\n  )\n\nsyntheticPopulation\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n-------------- \nsynthetic population  of size \n 85057 x 7 \n\nbuild from a sample of size \n11725 x 19\n-------------- \n\nvariables in the population:\nhhid,hsize,age,gender,state,pid,weight\n```\n:::\n:::\n\n\n#### Generate categorical variables\n\n***Approaches***\n\n-   model-based simulation\n\n    -   multinomial logistic regression `method = \"multinom\"`\n\n    -   decision tree (classification trees or random forest) `method = \"ctree\"` or `method = \"cforest\"`\n\n-   synthetic reconstruction `method = \"distribution\"` (when macro data is available)\n\n***Code***\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsyntheticPopulation <- simCategorical(\n  syntheticPopulation,\n  method = \"multinom\", # specify approach\n  # to find number of cores available, call parallel::detectCores()\n  nr_cpus = 8, # specify number of cpus for parallel computing\n  additional = c(\"economic_status\", \"citizenship\")\n  )\n\nsyntheticPopulation\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n-------------- \nsynthetic population  of size \n 85057 x 9 \n\nbuild from a sample of size \n11725 x 19\n-------------- \n\nvariables in the population:\nhhid,hsize,age,gender,state,pid,weight,economic_status,citizenship\n```\n:::\n:::\n\n\n***Demonstrating concept of synthetic reconstruction***\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# TODO: demonstrating concept of synthetic reconstruction\n# synRec <- simCategorical()\n```\n:::\n\n\n#### Generate continuous variables\n\n***Approaches***\n\n-   Multinomial logistic regression + Random drawing `method = \"multinom\"`: follow these steps\n\n    -   Categorize the continuous variable\n\n    -   Use regression model to get a category\n\n    -   Value from the largest category is drawn from a generalized Pareto distribution\n\n-   Logistic regression + Linear regression `method = \"lm\"` (necessary for semi-continuous distribution): follow these steps\n\n    -   Apply logistic regression model\n\n    -   Perform linear regression\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsyntheticPopulation <- simContinuous(\n  syntheticPopulation,\n  additional = c(\"netIncome\"), # specify continuous variable to simulate\n  upper = 200000, # set upper limit\n  zeros = TRUE, # specify whether simulated vars are semi-continuous (contains many 0 values)\n  imputeMissing = FALSE # whether to impute missing values using hock-deck\n)\n\nsyntheticPopulation\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n-------------- \nsynthetic population  of size \n 85057 x 11 \n\nbuild from a sample of size \n11725 x 19\n-------------- \n\nvariables in the population:\nhhid,hsize,age,gender,state,pid,weight,economic_status,citizenship,netIncomeCat,netIncome\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# view categories \nunique(pop(syntheticPopulation, var=c(\"netIncomeCat\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] (1.79e+04,2.06e+04]   (0,5.05e+03]          (8.4e+03,1.11e+04]   \n [4] 0                     (1.11e+04,1.38e+04]   (5.05e+03,8.4e+03]   \n [7] (2.35e+04,2.89e+04]   (1.59e+04,1.79e+04]   (2.89e+04,2e+05]     \n[10] (1.38e+04,1.59e+04]   (2.06e+04,2.35e+04]   [-4.37e+03,-3.11e+03)\n[13] [-5.81e+03,-4.37e+03) [-3.11e+03,0)        \n14 Levels: [-5.81e+03,-4.37e+03) [-4.37e+03,-3.11e+03) [-3.11e+03,0) ... (2.89e+04,2e+05]\n```\n:::\n:::\n\n\nCan also manually adjust values of the variables by accessing through `pop()`. The returned data is a `data.table`\n\n***Example:*** set net income for individuals at age \\<16 to `NA`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# enforce constraints\nincomeConstraints <- pop(syntheticPopulation, var = c(\"age\", \"netIncome\"))\nincomeConstraints$age <- as.numeric(incomeConstraints$age)\nincomeConstraints[age < 16, netIncome := NA]\n\n# override values for netIncome variable in synthetic population\npop(syntheticPopulation, var = c(\"netIncome\")) <- incomeConstraints$netIncome\n```\n:::\n\n\n#### Simulation of components\n\nSome variables in surveys are not collected directly but derived from other related variables. (e.g. net income computed from multiple income sources)\n\nThose related variables (referred to as components variables) can be generated by breaking down the synthetically generated continuous variable. This is done by re-sampling fractions from available survey data.\n\n`simPop` have function `simComponents()` to accomplish that.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# --- Categorize netIncome for use as a conditioning variable ------ \nsIncome <- manageSimPopObj(syntheticPopulation, var = \"netIncome\", sample=TRUE)\n# NOTE: it is equivalent to samp(syntheticPopulation, var = \"netIncome\") but samp() allows get-set multiple variables\n# using manageSimPopObj as getter/setter is usually safer \nsWeight <- manageSimPopObj(syntheticPopulation, var = \"weight\", sample=TRUE)\npIncome <- manageSimPopObj(syntheticPopulation, var = \"netIncome\") # netIncome for synthetic population\n\n# create breaks for categorizing\nbreaks <- getBreaks(\n  x = sIncome, # specify semi continuous variables\n  w = sWeight, # specify sample weight\n  upper = Inf, # upper bound of the variable, set as Inf to make sure both sample and pop values are in bound\n  equidist = FALSE # specify whether break points should be equal distance\n)\n\n# update categories for both population and and sample\nsyntheticPopulation <- manageSimPopObj(\n  syntheticPopulation, \n  set=TRUE, # specifying usinng setter\n  var = \"netIncomeCat\",\n  sample = TRUE, # update sample first\n  values = getCat(x = sIncome, breaks)# update categories with generated break points\n  )\nsyntheticPopulation <- manageSimPopObj(\n  syntheticPopulation, set=TRUE, var = \"netIncomeCat\",\n  sample = FALSE, # update population here \n  values = getCat(x = pIncome, breaks)\n  )\n\n# ----- Simulate  net income components ------ \nsyntheticPopulation <- simComponents(\n  simPopObj = syntheticPopulation, \n  total = \"netIncome\", # specify the variable for total\n  # specify the component variables\n  components = c(\"py010n\", \"py050n\", \"py090n\", \"py100n\", \"py110n\",   \"py120n\", \"py130n\", \"py140n\"), \n  # specify conditions for computing fractions of each component\n  conditional = c(\"netIncomeCat\", \"economic_status\"), \n  replaceEmpty = \"sequential\", \n  seed = 1)\n\nsyntheticPopulation\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n-------------- \nsynthetic population  of size \n 85057 x 19 \n\nbuild from a sample of size \n11725 x 20\n-------------- \n\nvariables in the population:\nhhid,hsize,age,gender,state,pid,weight,economic_status,citizenship,netIncomeCat,netIncome,py010n,py050n,py090n,py100n,py110n,py120n,py130n,py140n\n```\n:::\n:::\n\n\n#### Geographic allocation of population\n\nSynthetic population can be assigned to smaller geographical unit if data for population at lower geographical unit is available. In `simPop` this is done using `simInitSpatial()`\n\nRequired inputs: one or 2 table(s) with 3 variables\n\n-   Boarder geographical area (area in input sample data)\n\n-   Smaller area (area to assign the synthetic population to)\n\n-   Population for smaller area (either for household or individual)\n\n::: {.callout-note collapse=\"true\"}\n### Simulate census data with smaller geographical unit\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function for simulating data for smaller geographical unit for demonstration purpose\nsimulate_districts <- function(inp){\n  hhid <- \"hhid\"\n  region <- \"state\"\n  a <- inp[!duplicated(inp[, hhid]), c(hhid, region)]\n  \n  spl <- split(a, a[,region]) # get sample hhid-region pairs grouped by regions\n  regions <- unique(inp[, region]) # get regions in input sample data\n  \n  # assign each household to a smaller area\n  tmpres <- lapply(1:length(spl), function(x){\n    # simulate code for smaller area \n    codes <- paste(x, 1:sample(10:90, 1), sep=\"\")\n    spl[[x]]$district <- sample(codes, nrow(spl[[x]]), replace = TRUE)\n    spl[[x]]\n  })\n  \n  tmpres <- do.call(\"rbind\", tmpres)\n  tmpres <- tmpres[, -2]\n  out <- merge(inp, tmpres, by.x = hhid, by.y = hhid, all.x = TRUE)\n  invisible(out)\n}\n\n# create census data with district \ncensus <- simulate_districts(eusilcS)\n```\n:::\n\n:::\n\nCreate input data for assigning synthetic population to smaller geographical unit\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create the contingency table for household per region\ntabHH <- as.data.frame(\n  xtabs(weight ~ state + district, data = census[!duplicated(census$hhid), ])\n  )\n\n# create the contingency table for population per region\ntabP <- as.data.frame(\n  xtabs(weight ~ state + district, data = census)\n)\n```\n:::\n\n\n***Code for geographical allocation***\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsyntheticPopulation <- simInitSpatial(\n  syntheticPopulation, \n  # either tspatialHH or tspatialP is required. Assigning values for both also works.\n  tspatialHH = tabHH, # specify contingency table for household\n  tspatialP = tabP, # specify contingency table for individual\n  additional = \"district\", # specify variable for smaller area (must exist in tspatial table)\n  region = \"state\" # specify variable for larger area (must exist in tspatial table)\n)\n\nsyntheticPopulation\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n-------------- \nsynthetic population  of size \n 85057 x 20 \n\nbuild from a sample of size \n11725 x 20\n-------------- \n\nvariables in the population:\nhhid,hsize,age,gender,state,pid,weight,economic_status,citizenship,netIncomeCat,netIncome,py010n,py050n,py090n,py100n,py110n,py120n,py130n,py140n,district\n```\n:::\n:::\n\n\n### Calibrate the synthetic population\n\n***Approach***\n\nCalibrate against a known distribution of the population using Combinatorial Optimization\n\n***Code for calibrating***\n\nobtain a \"known distribution\" from synthetic data for demonstration purpose\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create another synthetic data to obtain \"known distribution\"\ncensus <- simStructure(data = inputData, method = \"direct\", basicHHvars = c(\"age\", \"gender\", \"state\"))\ncensus <- simCategorical(census, additional = c(\"economic_status\", \"citizenship\"))\n\n# create known distribution\ncensus <- data.frame(pop(census))\nknownDistribution <- as.data.frame(\n  xtabs(~ state + gender + economic_status, data=census)\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# add known distribution to synthetic population\nsyntheticPopulation <- addKnownMargins(syntheticPopulation, knownDistribution)\n\n# and calibrate using simulated annealing\nadjustedPopulation <- calibPop(\n  syntheticPopulation, \n  split = \"state\", # split by region\n  temp = 1, # starting temperature for simulated annealing\n  epsP.factor = 0.00005, # adjust factor of acceptance error on individual level\n  maxiter = 200, temp.cooldown = 0.85, factor.cooldown = 0.85,\n  min.temp = 0.001, nr_cpus = 8\n) \n```\n:::\n\n\n### Validate synthetic population with built-in tools\n\n***Computational tools***\n\n`spTable()` computes contingency table for survey data and simulated data\n\n***Visualization tools***\n\n`spMosaic()` for mosaic plot\n\n`spCdfplot()` for cumulative distribution plot\n\n`spBwplot()` for boxplot\n\n\n::: {.cell warnings='false'}\n\n```{.r .cell-code}\n# plot cdf for netIncome conditioning on state\nspCdfplot(syntheticPopulation, x = \"netIncome\", cond = \"state\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in spCdf(x, w, ...): number of finite values in 'x' is smaller than\n'n': no approximation\nWarning in spCdf(x, w, ...): number of finite values in 'x' is smaller than\n'n': no approximation\nWarning in spCdf(x, w, ...): number of finite values in 'x' is smaller than\n'n': no approximation\nWarning in spCdf(x, w, ...): number of finite values in 'x' is smaller than\n'n': no approximation\nWarning in spCdf(x, w, ...): number of finite values in 'x' is smaller than\n'n': no approximation\nWarning in spCdf(x, w, ...): number of finite values in 'x' is smaller than\n'n': no approximation\n```\n:::\n\n::: {.cell-output-display}\n![](synthetic_population_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# check age-gender distribution\nspCdfplot(syntheticPopulation, x = \"age\", cond = \"gender\")\n```\n\n::: {.cell-output-display}\n![](synthetic_population_files/figure-html/unnamed-chunk-20-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# compare generated household structure of original vs simulated data\ntab <- spTable(syntheticPopulation, select = c(\"gender\", \"state\", \"hsize\"))\nspMosaic(tab, labeling = labeling_border(abbreviate = c(state = TRUE)))\n```\n\n::: {.cell-output-display}\n![](synthetic_population_files/figure-html/unnamed-chunk-20-3.png){width=672}\n:::\n\n```{.r .cell-code}\n# check state-netIncome of original vs simulated data\nspBwplot(\n  syntheticPopulation, x = \"netIncome\", cond = \"economic_status\"\n)\n```\n\n::: {.cell-output-display}\n![](synthetic_population_files/figure-html/unnamed-chunk-20-4.png){width=672}\n:::\n:::\n",
    "supporting": [
      "synthetic_population_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}